1. Проблематика автоматизации интеллектуального труда. Эволюция развития технических средств
	1. Проблематика автоматизации интеллектуального труда
		1. Была проблема с хранением и представлением большого объема информации (как собрать, хранить, обработать) . Из-за разных видов информации в вычислительной среде. 
		2. Самая большая проблема- это переход от естественного языка к формальному языку представления. Семантическая модель (то как в жизни выглядит задача, информационная структура) -> синтаксическая модель (оптимальная организация). Потом техническая реализация, где мы будем эти модели реализовывать. 
		3. Объективизация знаний - проблема "забрать" у специалистов их профессиональные знания. 
		4. Интеграция - проблема согласования данных. Как, что и куда передается.
		5. Ошибки - $$ З = е^t, где ->З- затраты, t- время.обнаружения.ошибки$$
	2. Эволюция развития технических средств
		1. Чем больше информации хранится, тем сложнее ей управлять.
		2. Для уменьшения дублирования начинаем ссылаться на уже имеющиеся данные.
		3. В результате эволюции производство осуществляется несколькими способами:
			1. Уникальный - все этапы жизненного цикла осуществляются одним субъектом. 
			2. Кустарный - разделен на процесс создания и процесс использования. Особенностью является то, что кустарь не моделирует изделие, изменение формы происходит методом проб и ошибок, форма изделия- хранилище информации. 
			3. Промышленный:
				1. Переход к промышленному производству осуществился благодаря появлению модели в виде чертежа.
				2. Единичное производство
				3.  Серийное производство
				4. Массовое производство
				5. Особенности:
					1. Возникает процесс конструирования чертежным способом
					2. Деталировка, масштабирование, сборочные чертежи
					3. Разделение труда и специализации 
					4. Зависимость различных технологических процессов
			4. В связи с появлением промышленного способа производства появляется проблема создания технических средств.
2. Проблема создания технических средств.
	1. Промышленный способ производства требует сочетания и увязки знаний обо всех этапах жизненного цикла изделия. Поэтому требовались специалисты широкого профиля. Объектом анализа становятся интеллектуальная деятельность, предшествующая выполнению проекта, то есть требуется объектирование интеллектуального труда.
	2. В середине 20-го века произошла научно-техническая революция. Человечество стало создавать новые технологии и средства. Требовалось разрешение проблемы между объемом информации и возможностью человека воспринимать эту информацию. 
	3. Противоречие между объемом информации и знаниями на традиционных носителях и пропускной способностью человеческой памяти.	
### **Проблема создания технических средств в середине XX века**

#### **1. Проблема интеграции знаний и объективации интеллектуального труда**

- **Суть:** Промышленный способ производства требует **сквозного учёта** всех этапов ЖЦИ (от проектирования до утилизации)
- **Следствие:** Нужны специалисты-энциклопедисты, но их не хватает
- **Решение требуется:** Вынести интеллектуальный труд из головы инженера в формализованные процессы и системы
- **Пример:** Раньше опытный технолог "знал" как изготовить деталь; теперь нужно записать это знание в технологическую карту, которую поймёт и компьютер
#### **2. Проблема информационного взрыва в эпоху НТР**
- **Суть:** Научно-техническая революция привела к **экспоненциальному росту** объёмов информации
- **Конфликт:** Объём информации ↑↑↑ vs. Возможности человеческого восприятия →
- **Требуется:** Технические средства как "усилители" интеллекта
- **Пример:** При проектировании самолёта нужно учесть тысячи параметров; человек физически не может этого сделать без ЭВМ
#### **3. Проблема несоответствия носителей и восприятия**
- **Суть:** Традиционные носители (бумага) неэффективны для хранения и поиска больших объёмов данных
- **Противоречие:**
    - Информация существует (в справочниках, чертежах, отчётах)
    - Но недоступна для оперативного использования человеком
- **Требуется:** Новые носители и средства доступа к информации
- **Пример:** Чертежи сложного изделия занимают целую комнату; найти конкретный узел — задача на часы

3. Автоматизация этапов жизненного цикла
	1.  Жизненный цикл- это совокупность производственных процессов от зарождения идеи до утилизации изделия.
	2. Этапы жизненного цикла:
		1. Осмысление потребности
		2. Исследование и анализ осуществимости
		3. Проектирование и конструирование
		4. Подготовка производства
		5. Изготовление
		6. Эксплуатация
		7. Утилизация
	3. Специфика и общие черты  прикладных автоматизированных систем ПАС
		1. $$ПАС=ФЧ+ОЧ$$
			1. ФЧ- Функциональная часть - отражает структуру функций автоматизируемой предметной задачи.
			2. ОЧ - обеспечивающая часть  - комплекс средств автоматизации и виды обеспечения 
			3. ![[ПАС.png]]
	4. Автоматизация:
		1. Исследование (Автоматизированные системы научных исследований АСНИ)
		2. Проектирование (Системы автоматизированного проектирования САПР)
		3. Подготовка производства (Автоматизированные системы технологической подготовки производства АСТПП)
		4. Изготовление (Автоматизированные системы управления технологическим процессом (АСУТП) (ЧПУ+ГПС гибкие производственные системы))
		5. Эксплуатация (Автоматизированные системы управления АСУ)
	5. Сами этапы(вроде как):
		1. Обеспечение - совокупность средств, методов для функционирования объекта
		2. Информационное обеспечение - совокупность единой системы классификаций и кодирования информации, унифицированных систем документации и массивов информации, использующихся в автоматизированной системе.
		3. Внешнее информационное обеспечение - это методы и средства идентификации объектов, предъявление их во входных документах
		4. Внутреннее информационное обеспечение - это методы и средства преобразования внешнего представления данных в машинные, организация машинных массивов и информации и преобразование из машинного представление во внешнее.
4. Информационные технологии, этапы развития
	1. Технология - упорядоченная последовательность действий. Производственная задача описывается последовательностью компонент(в скобках, что это есть для человека):
		1. Предмет обработки (информация)
		2. Процесс обработки (виды процессов по обработке информации )
		3. Субъект обработки (человек)
		4. Средства обработки (программно-технические средства)
		
		Информационная технология - это процесс циркуляции и переработки информации. 
	1. Информационные процессы. Выделяют => виды информационных процессов:
		1. Сбор информации  (Обеспечение этапов производственного цикла и система управления таким объемом сведений, который позволяет выполнять поставленные задачи)
		2. Хранение информации (перенос информации во времени)
		3. Передача информации (перенос информации в пространстве из одной точки в другую)
		4. Переработка информации (целесообразная последовательность действий, направленная на обеспечение процедуры принятия решений, либо получение результата)
		5. Вывод информации (доведение информации до пользователя любым удобным для него виде и удобное для него время)
		6. ![[Технические средства.png]]
		   **Образная информация** — это информация, представленная в виде **зрительных образов, изображений, графики, схем, чертежей**.
		   **Проще говоря:** Это всё, что можно **УВИДЕТЬ** (но не текст в обычном понимании).
		
5. Электронная обработка данных, эволюция и проблемы
	1. *Данные* -Это форма представления сведений в процессе их хранения и обработки (в выч среде за смысл отвечает человек) *или* Это фактическое описание любого явления, которое представляет ценность (в ест среде они идут рука об руку с контекстом).
	2. Что такое обработка данных:
		1. Это выполнение систематических последовательных действий с данными.
		2. Информация по задаче образует информационную среду, которая является совокупностью носителей данных, включенных в обработку при решении этой задачи
		3. Данные обычно связаны, а взаимосвязанные данные называют системами данных.
	3. Этапы обработки данных:
		1. Электронная обработка данных
		2. Информационные технологии
		3. Новые информационные технологии 
		4. Мульти информационные среды, средства и технологии
	4. Стадии развития ЭОД:
		1. Программирование кодов, где коды - это адреса физической памяти, адрес-переменная, а содержимое ячейки - значение переменной. 
		2. Символическое программирование - вводятся имена переменных
		3. Появление языков программирования высокого уровня. Выделяют 2 уровня: *логический и физический*
			1. автоматически резервируется память для очередного типа данных, число переменных начинает резко возрастать.
	5. Системы хранения данных на основе файлов.**Системы управления файлами (СУФ)**
		1. Были нужны, потому что в начале развития информатики информационные системы работали непосредственно с файлами данных. 
			1. Их логическая структура обычно определялась для конкретной задачи или группы задач самим разработчиком. 
		2. Главным недостатком этой системы связан с тем, что множество однотипных записей, предназначенных для решения конкретной задачи приводят к избыточности. Это порождает проблему *противоречивости данных*, которая усугубляется слабым контролем *достоверности данных*
		3. При объединении записей для снятия противоречивости, возникают следующие трудности:
			1. Длинные записи трудоемки в ведении
			2. Низкая гибкость в системе с длинными записями
			3. Возможность несанкционированного доступа, при низкой защите.
			4. Восстановление данных очень сложное и долгое
			5. Эксплуатация очень сложная и дорогая
		4. Основные недостатки:
			1. Ограничение разделение данных
			2. Ограничение по доступности
			3. Сложность в управлении
	6. **Базы данных** - организация данных, предполагающая использование СУБД, а также свой подход к организации информационной системы 
		1. Их основное отличие в том, что БД имеют несколько назначений и одно представление данных, а СУФ несколько назначений и несколько представлений.
	7. **СУБД** - комплекс программно-аппаратных средств, обеспечивающих доступ и управление данными. Требования к СУБД:
		1. Эффективное выполнение функций предметной области
		2. Минимизация избыточности 
		3. Безопасность 
		4. Простота в эксплуатации 
		5. Простота в физической реорганизации
		6. Возможность централизованного управления
		7. Упрощение приложений
	8. **Банк данных (БнД)** - система специальным образом организованных данных, программных, технических, языковых, организационно-методических средств, предназначенных для обеспечения центрального накопления и коллективного многоцелевого использования данных.
		1. Ядро любой информационной системы (ИС) составляет информационная база, преобладающей формой организации которой является *База данных*
		2. *База данных* представляет собой организацию данных и предполагает использование СУБД, а также специфического подхода к организации ИС
6. Понятие «данные», «информация», «знание».
	1. *Данные*
		1. Это фактическое описание любого явления, которое представляет ценность.
		2. Это форма представления сведений в процессе их хранения и обработки.
	2. Универсальным средством представления данных, информации и знаний является естественный язык ( *ЕЯ* ). В *ЕЯ* данные и их интерпретация осуществляется совместно.
	3. В вычислительной среде данные хранятся на логических носителях, а их интерпретация возлагается на человека. 
	4. *Информация*:
		1. Это содержание сведений об объектах, явлениях и событиях реального мира
		2. Это приращение знаний, которые могут быть выведены на основе данных
		3. Это отрицательное приращение энтропии
			1. $$I=-deltaЭ$$
	5. *Знание* - это целостная систематизированная совокупность научных понятий о закономерностях природы, общества и сознания (мышления), накопленные человечеством в процессе активной образовательной деятельности и направленная на дальнейшее познание и преобразование окружающего мира
7. Информационное моделирование. Основные понятия
	1. **Модель** - абстракция, позволяющая изучить и исследовать окружающий мир.
	2. **Модель данных** - это совокупность структуры данных и операций их обработки. Это:
		1. Множество элементов данных и их состояний
		2. Правила порождения структур данных и их состояний
		3. Правила порождения ограничений на структуры данных и на их состояния
		4. Множество операций над состояниями данных
	3. Классификация основных моделей данных:
		1. *Иерархическая* - Организует данные в виде древовидной (горизонтальные связи отсутствуют) структуры и является реализацией логических связей между данными типа родовидовых отношений или отношений **"Часть-целое"**
			1. Элементы описания данных: простое поле, группа, запись, групповое отношение и БД
			2. ![[Иерархическая модель.png]]
			3. Условия:
				1. Иерархия имеет, и только один, исходный узел (корень) - начало древа. 
				2. Узел имеет непустое множество атрибутов, которые описывают объект, моделируемый в данном узле.
				3. Порожденные узлы могут добавляться в древо как в вертикальном, так и в горизонтальном направлении.
				4. Доступ к порожденным узлам возможен только через исходный узел => только один путь доступа к каждому узлу.
				5. Возможно существование нескольких экземпляров узлам каждого уровня. При этом каждый экземпляр исходного узла начинает логическую запись.
			4. Недостатки:
				1. Сложность отображения связи "многие-ко-многим"
				2. Сложность включения новых объектов и удаления устаревших непосредственно в базе данных(особенно обновление и удаление связей)
				3. Неоднозначность представления данных о предметной области.
				4. ![[Управление ИОД.png]]
		2. *Сетевая*- Это расширение иерархического подхода, путем разрешения связывания любых узлов с любыми 
			1.  Состоит из набора записей и набора связей между этими записями.
			2. У вершины может быть боле одного предка, граф может быть ориентированным 
			3. Тип связи определяется для двух типов записи (предка и потомка). Экземпляр типа связи состоит из одного экземпляра типа записи предка и упорядоченного набора экземпляров тип записи потомка.
			4. ![[Схема СМД.png]]
			5. Операции:
				1. Найти конкретную запись в наборе однотипных записей
				2. Перейти от предка к первому потомку по некоторой связи
				3. Перейти к следующему потомку по некоторой связи
				4. Перейти от потомка к предку по некоторой связи
				5. Создать новую запись
				6. Уничтожить запись
				7. Модифицировать запись
				8. Включить в связь 
				9. Исключить из связи
				10. Переставить в другую связь
		3. *Реляционная* - это совокупность данных, состоящая из набора двумерных таблиц. Более высокий уровень абстракции, по сравнению с иерархической и сетевой моделями 
			1. **Отношение** - подмножество декартова произведения множеств, называемых доменами.
			2. Каждый **домен** состоит из множества элементов $D_i$:$$D_i={d_{in}}$$
			3. **Отношение** - это множество элементов, называемых кортежами, каждый из которых имеет вид $d_{i1},...d_{in}$ , причем на первом месте стоит элемент из домена $D1$, а на последнем элемент из домена $D_n$ $$P={(d_{i1},d_{i2},...,d_{in})}$$
			4. Сопоставление геометрического и табличного представления отношения
		4. В основу иерархической и сетевой моделей положена теория графов, в основу реляционной модели- теоретико-множественный подход и алгебра отношений.
8. 8. Реляционная модель данных. Теоретические основы (математический аппарат, основные понятия)
	1. **Реляционная модель данных** — логическая модель представления данных, предложенная **Э. Коддом**, являющаяся более высоким уровнем абстракции по сравнению с иерархической и сетевой моделями. В реляционной модели данные представляются в виде совокупности **отношений**, которые интерпретируются как двумерные таблицы.
			1. **Отношение** - это подмножество декартова произведения доменов, представленное в виде множества кортежей. $$P⊆D_1×D_2...D_n$$
				1. это множество элементов, называемых кортежами, каждый из которых имеет вид $d_{i1},...d_{in}$ , причем на первом месте стоит элемент из домена $D1$, а на последнем элемент из домена $D_n$ $$P={(d_{i1},d_{i2},...,d_{in})}$$
			2. Каждый **домен** состоит из множества элементов $D_i$:$$D_i={d_{in}}$$
			3. Сопоставление геометрического и табличного представления отношения
				1. ![[Сопоставление представлений.png]]
			4. Каждое отношение может быть интерпретировано как **предикат**, а каждый кортеж — как **истинное высказывание**, удовлетворяющее этому предикату. Реляционная модель опирается на формальную логику, что обеспечивает строгую семантику данных и запросов.
			5. **Реляционная алгебра** - Формальный аппарат операций над отношениями. К базовым операциям реляционной алгебры относятся:
				1. - выбор (σ);
				2. проекция (π);
				3. объединение (∪);
				4. разность (−);
				5. декартово произведение (×);
				6. соединение (⋈).
				7. Операции реляционной алгебры замкнуты: результат любой операции также является отношением.
	2. Основные понятия реляционных баз данных
		1. **Тип данных** — множество допустимых значений определённого вида (целые числа, строки, даты и т.д.).
		2. **Домен** — допустимое потенциальное множество значений заданного типа данных.
		3. **Атрибут**
		    - Атрибут отношения — пара вида  
		        ⟨Имя_атрибута : Имя_домена⟩.
		    - Имена атрибутов должны быть уникальны в пределах отношения.
		4. **Кортеж**
		    - Набор именованных значений заданного типа.
		    - Представляет собой множество пар  
		        {Имя атрибута, значение}.
		    - Содержит одно вхождение каждого имени атрибута схемы отношения.
		    - Арность кортежа совпадает с арностью соответствующей схемы отношения.
		5. **Отношение**
			- Множество кортежей, соответствующих одной схеме отношения.
		6. **Схема отношения**
		    - Именованное множество пар  
		        {имя атрибута, имя домена}.
		7. **Схема базы данных (в структурном смысле)**
		    - Набор именованных схем отношений.
		8. **Мощность отношения**
    
		    - Количество кортежей (строк) в отношении.
        
		9. **Арность (степень) отношения**
	    
		    - Количество доменов (атрибутов).
	        
		    - Размерность отношения или кортежа называется арностью и определяется числом доменов.
	3. Свойства отношений
		1. **Отсутствие дубликатов кортежей**  
		    Каждое отношение является множеством, поэтому одинаковые кортежи не допускаются.  
			Из этого свойства вытекает наличие у отношения **уникального идентификатора (ключа)** — набора атрибутов, однозначно определяющих кортеж.
		2. **Отсутствие упорядоченности кортежей**  
		    Порядок строк не имеет значения, что обеспечивает независимость логического представления данных от физического хранения.
		3. **Отсутствие упорядоченности атрибутов**  
		    Атрибуты отношения не упорядочены, поскольку схема отношения является множеством пар {имя атрибута, имя домена}.
		4. **Атомарность значений атрибутов**  
		    Значения всех атрибутов являются атомарными, то есть неделимыми и принадлежащими одному типу данных.
9. Базовые понятия реляционных баз данных
	1. **Реляционная база данных** — это совокупность логически связанных отношений, организованных в соответствии с реляционной моделью данных.
	2.  **Тип данных** определяет множество допустимых значений и операций над ними (целые числа, строки, даты и т.д.).
	3.  **Домен** — допустимое потенциальное множество значений заданного типа данных. Домены используются для задания ограничений целостности и могут применяться в разных отношениях.
	4. **Атрибут** — именованная характеристика сущности, принимающая значения из определённого домена. Атрибут отношения задаётся парой: $⟨Имя_атрибута : Имя_домена⟩$ Имена атрибутов уникальны в пределах отношения.
	5. **Кортеж** — это набор именованных значений атрибутов, соответствующих одной строке отношения. С формальной точки зрения:
		- кортеж — множество пар {имя атрибута, значение};
		- содержит по одному значению для каждого атрибута схемы;
		- арность кортежа равна арности схемы отношения.
	6.  **Отношение** — это множество кортежей, определённых на одной схеме отношения. Свойства отношения:
		- отсутствие дубликатов кортежей;
		- отсутствие упорядоченности кортежей;
		- отсутствие упорядоченности атрибутов;
		- атомарность значений.
	7. **Схема отношения** — именованное множество пар {имя атрибута, имя домена}.
	8. **Схема базы данных** — совокупность схем отношений и связей между ними.
	9. **Ключ** — набор атрибутов, однозначно идентифицирующий кортеж. Различают:
		- потенциальные ключи;
		- первичный ключ;
		- внешние ключи.
	10. Арность и мощность
		- **Арность** — количество атрибутов отношения.
		- **Мощность** — количество кортежей.
10. Реляционная модель данных (состав модели и элементы)
	1. Реляционная модель данных состоит из **трёх взаимосвязанных частей**, каждая из которых описывает отдельный аспект реляционного подхода.
	2. **Структурная часть** определяет способ представления данных. В реляционной модели: 
		1. единственной структурой данных является **нормализованное n-арное отношение**
		2. данные представлены в виде отношений;
		3.  структура отношения определяется доменами, атрибутами и кортежами.
	3. **Целостная часть** описывает ограничения, которые должны выполняться для любых отношений в реляционных базах данных. Основные ограничения целостности:
		- **целостность сущностей** — первичный ключ не может быть неопределённым;
		- **целостность внешних ключей** — значения внешних ключей должны ссылаться на существующие кортежи;
		- **доменная целостность** — значения атрибутов принадлежат соответствующим доменам.
	4. **Манипуляционная часть** определяет средства работы с данными.
			Существуют два формальных механизма манипулирования:
			- **реляционная алгебра**;
			- **реляционное исчисление**.
	5. Реляционная алгебра
		Основана на теории множеств и включает набор основных операций)
		- объединение;
		- разность;
		- пересечение;
		- декартово произведение;
		- проекция;
		- селекция;
		- соединение;
		- деление.
	6. Реляционное исчисление
		Основано на логике предикатов первого порядка и существует в двух формах:
		- исчисление доменов;
		- исчисление предикатов.    
	7. Ключевое свойство
		1. Все механизмы манипулирования **замкнуты относительно понятия отношения**: результатом любых операций являются отношения.
11. Реляционная алгебра. Элементы реляционной алгебры: Объединение, Разность, Декартово произведение и Проекция.
	1. Основная идея реляционной алгебры состоит в том, что если отношения являются множествами, то средства манипулирования отношениями могут базироваться на традиционных теоретико-множественных операциях, дополненных некоторыми специальными операциями, специфичными для баз данных. 
	2. Набор основных алгебраических операций состоит из восьми операций, которые делятся на 2 класса:
		1. Теоретико-множественные операции
		2. Специальные реляционные операции
	3. **Объединение**
		1. Объединением отношений R и S называется отношение Q, которое представляет собой множество кортежей, принадлежащих R или S или им обоим. Атрибуты результата не поименованы, дублирующие кортежи удваиваются . Основное ограничение - одинаковая арность(количество столбцов) 
		2. $$Q=R∪S$$
	4. **Разность**
		1. Разностью двух отношений R и S называется отношение Q, представляющее собой множество кортежей, принадлежащих R и не предлежащих S. Основное ограничение - одинаковая арность
		2. $$Q=R-S$$
	5. **Декартово произведение** 
		1. Пусть отношение R и S имеют арность k1 и k2 соответственно. Тогда декартовым произведением $R×S$ отношений R и S называется отношение Q, в котором множество кортежей образуют длину $k1+k2$. Основное ограничение - арность отношений складываются, а мощности перемножаются
		2. $$Q=R×S$$
	6. **Проекция**
		1. Проекция - понижение арности, "выборка по столбцам". *Унарная операция*, которая позволяет получить доступ к определенной части отношения. Идея этой операции заключается в том, что берется некоторое отношение R, удаляются некоторые из его компонентов и (или) переупорядочиваются оставшиеся компоненты.
		2. $$Q=π_{i1...im}(R),i_m<k_1$$
12. Реляционная алгебра. Элементы реляционной алгебры: Селекция, Пересечение, Частное Соединение
	1. 1. Основная идея реляционной алгебры состоит в том, что если отношения являются множествами, то средства манипулирования отношениями могут базироваться на традиционных теоретико-множественных операциях, дополненных некоторыми специальными операциями, специфичными для баз данных. 
	2. Набор основных алгебраических операций состоит из восьми операций, которые делятся на 2 класса:
		1. Теоретико-множественные операции
		2. Специальные реляционные операции
	3. Селекция
		1. Выбор по критерию, выборка по строкам. *Унарная операция*, которая позволяет получить доступ к определенной части отношения.
		2. Пусть F - формула, образованная:
			-  Операндами, являющимися константами(постоянными) или номерами компонентов
			- Арифметическими операторами сравнения $<,=,>,≥,≤,≠$
			- Логическими операторами и, или, нет
		3. Селекция работает с одним отношением и определяет результирующее отношение Q, которое содержит только те кортежи отношения, которые удовлетворяют заданному предикату F. Формула селекции может ссылаться на столбцы по именам, если они именованы. Константы в формулах должны быть в кавычках, чтобы отличать от номеров или имен столбцов
		4. $$Q_t=σ_F(R)$$
	4. Пересечение
		1. Пересечением отношения R и S является отношение Q, принадлежащее одновременно R и S. Основное ограничение - одинаковая арность.
		2. $$Q=R∩S$$$$Q=R-(R-S)$$
	5. Частное
		1. Пусть R и S является отношением арности r и s, при этом арность r > s, и отношение S - непустое, тогда частное отношение Q, есть набор кортежей (строк) отношения R, которые соответствуют комбинации всех кортежей отношения S. Основное ограничение - необходимо, чтобы в отношении S была часть атрибутов, которые есть в отношении R. В результирующем отношении присутствуют только те атрибуты отношения отношения R, которых нет в отношении S 
		2. $$Q=R÷S$$
	6. Соединение
		1. При соединении двух отношений по некоторому условию образуется результирующее отношение, кортежи которого являются конкатенацией кортежей первого и второго отношений и удовлетворяют этому условию.
		2. $$Q=R \mathop{\bowtie}_{i@j}\,S$$
		3. Q – соединение исходных отношений R и S, где $i∈R, j∈S$, @ – арифметический оператор сравнения: $>,≥,=,<,≤,$
		4. Существуют три варианта соединений:
			1. Естественное
				- Если есть одинаковые столбцы, то выполняется $$Q=R⋈S$$
				- Существует тогда и только тогда, когда столбцы поименованы и существует по крайней мере хотя бы 1 общий столбец.
				- K=K1+K2−N
				- где **K** – арность результирующего отношения,  
				- **K1** – арность первого отношения,  
				- **K2** – арность второго отношения,  
				- **N** – количество общих столбцов.
				- Определение естественного соединения базируется на понятии равенства кортежей.
			2. Эквисоединение
				- иначе, если @ – является оператором сравнения «=»,  то выполняется:$$Q=R⋈_{i=j}S$$
				- Соединение, в котором данные в столбцах сравниваются на равенство и все столбцы соединяемых отношений включаются в результат.
				- K=K1+K2,@ всегда «=».
				- Результат любого соединения по эквивалентности должен включать два атрибута, характеризующихся тем свойством, что значения этих двух атрибутов равны в каждом кортеже данного отношения.
			3. Тета-соединение
				- иначе , @ – является оператором сравнения, отличным от сравнения на равенство, и выполняется **Тета-соединение** $$Q=R \mathop{\bowtie}_{i@j}\,S$$. 
				- Операция предназначена для тех случаев, когда возникает необходимость соединить два отношения на основе некоторого оператора сравнения, отличного от сравнения на равенство.
				- Результатом становится отношение с тем же заголовком, как и у декартова произведения (отношения не должны иметь общих имен атрибутов), с телом, состоящим из множества всех кортежей, и выражение $i@j$ принимает значение TRUE для данного кортежа.
				- K=K1+K2, @ может быть $>,≥,<,≤$.
				- В оператор соединения можно включать произвольное число дополнительных критериев отбора. Порядок следования этих критериев и условия соединения не имеют значения.
13. Реляционная алгебра Законы операций (композиции)
	1. Реляционная алгебра и оптимизация запросов
		1. Реляционная алгебра является формальным аппаратом манипулирования отношениями, основанным на теории множеств. Один и тот же алгоритм вычислений может быть представлен в виде различных выражений реляционной алгебры, которые являются **эквивалентными**, но отличаются эффективностью выполнения.
		2. Мерой оценки производительности является количество операций ввода-вывода кортежей отношений.
		3. Основная задача оптимизации запросов:
				- минимизировать количество обрабатываемых кортежей;
				- выполнять операции селекции и проекции как можно раньше;
				- по возможности избегать дорогостоящих операций декартова произведения и соединения.
		4. Эквивалентность выражений
				1. Два выражения реляционной алгебры \(E_1\) и \(E_2\) называются эквивалентными, если они определяют одно и то же отображение для любых допустимых отношений: Результат вычисления эквивалентных выражений всегда совпадает.$$ E_1 \equiv E_2$$
		5. **Общие стратегии оптимизации**:
				1. Выполнять операции селекции по возможности раньше.
				2. Собирать в каскады проекции и селекции.
				3. Комбинировать проекции с предшествующими или последующими дву­местными операциями.
				4. Комбинировать некоторые селекции с предшествующим декартовым произведением и выполнять вместо них соединения.
				5. и др.
	2. ЗАКОНЫ ОПЕРАЦИЙ РЕЛЯЦИОННОЙ АЛГЕБРЫ
		1. Закон коммутативности.
			1. Бинарная операция называется коммутативной, если для любых отношений A и B выполняется равенство:  $A ∘ B = B ∘ A$  В реляционной алгебре коммутативными являются операции:
					- объединение: A ∪ B = B ∪ A
					- пересечение: A ∩ B = B ∩ A
					- декартово произведение: A × B = B × A
					- соединение: A ⋈ B = B ⋈ A
					Операции разности и деления коммутативными не являются.
		2. Закон ассоциативности
				Бинарная операция называется ассоциативной, если для любых A, B и C выполняется:  
				A ∘ (B ∘ C) = (A ∘ B) ∘ C
				Ассоциативными являются операции
				- объединение
				- пересечение
				- декартово произведение
				- соединение
				Это позволяет изменять порядок группировки операций без изменения результата.
		3. Закон идемпотентности и поглощения
			1. Идемпотентной называется операция, для которой выполняется: A ∘ A = A
			2. В реляционной алгебре идемпотентными являются
					1. объединение: A ∪ A = A
					2. пересечение: A ∩ A = A
					3. естественное соединение: A ⋈ A = A
					4. Операции декартова произведения, разности и деления идемпотентными не являются.
		4. Законы поглощения:
				1. A ∪ (A ∩ B) = A
				2. A ∩ (A ∪ B) = A
		5. Распределительный закон
			1. Унарный оператор распределяется по бинарной операции, если: f(A ∘ B) = f(A) ∘ f(B)
	3. РАСПРЕДЕЛИТЕЛЬНЫЕ ЗАКОНЫ В РЕЛЯЦИОННОЙ АЛГЕБРЕ
		1. Распределительный закон для бинарных операций
			1. В реляционной алгебре:
				1. объединение распределяется по пересечению: $A ∪ (B ∩ C) = (A ∪ B) ∩ (A ∪ C)$
				2. пересечение распределяется по объединению:  $A ∩ (B ∪ C) = (A ∩ B) ∪ (A ∩ C)$
			2. Распределительный закон для селекции (выборки)
				1. Операция селекции распределяется по операциям:
					1. объединения
					2. пересечения
					3. разности
					4. То есть селекцию можно применять к каждому операнду отдельно. Также селекция может распределяться по операции естественного соединения при разложении условия на части. 
			3. Распределительный закон для проекции
				1. Операция проекции распределяется по операциям
					1. объединения
					2. пересечения
					3. Проекция распределяется по операции естественного соединения при условии, что в результате проекции сохраняются все атрибуты соединения.
	4. ЗАКОНЫ КАСКАДОВ СЕЛЕКЦИИ И ПРОЕКЦИИ
		1. Законы каскадов селекции.
			1. Последовательность операций селекции одного и того же отношения может быть заменена одной операцией селекции, в которой условия объединены логической операцией AND. Это позволяет уменьшить количество проходов по данным.
		2. Законы каскадов проекций
				1. Последовательные операции проекции могут быть объединены в одну, если итоговое множество атрибутов является подмножеством исходного.
	5. ПРАКТИЧЕСКОЕ ЗНАЧЕНИЕ 
		1. Законы операций реляционной алгебры позволяют
			1. выполнять эквивалентные преобразования выражений;
			2. уменьшать объём обрабатываемых данных;
			3. оптимизировать выполнение запросов;
			4. служат теоретической основой оптимизаторов запросов в СУБД.
			5. В практических системах такие преобразования называют оптимизацией запросов.
14. Проектирование реляционных БД с использованием нормализации. Определения, проблематика, этапы нормализации.
	1. Проектирование реляционной базы данных — это процесс логического описания структуры данных, обеспечивающий их корректное хранение, целостность и эффективную обработку. Одним из основных методов проектирования реляционных БД является **нормализация**.
	2. ОПРЕДЕЛЕНИЕ НОРМАЛИЗАЦИИ
		1. Нормализация — это формальный процесс преобразования схемы реляционной базы данных в набор отношений, удовлетворяющих определённым **нормальным формам**, с целью:
			1. устранения избыточности данных;
			2. предотвращения аномалий обновления;
			3. обеспечения целостности данных;
			4. повышения логической ясности структуры БД.
		2. Нормализация основана на анализе **функциональных зависимостей** между атрибутами отношений.
	3. ПРОБЛЕМАТИКА ПРОЕКТИРОВАНИЯ БД БЕЗ НОРМАЛИЗАЦИИ
		- При отсутствии нормализации в базе данных возникают следующие проблемы:
		1. **Избыточность данных**  
			1. Одни и те же данные хранятся в нескольких местах, что увеличивает объём БД.
		2. **Аномалия вставки**  
			1. Невозможно добавить данные об одной сущности без добавления данных о другой.
		3. **Аномалия удаления**  
			1. При удалении одних данных теряется информация о других сущностях.
		4. **Аномалия обновления**  
			1. При изменении значения требуется обновлять его в нескольких строках, что приводит к несогласованности данных. 	
		- Эти проблемы делают базу данных нестабильной и трудно сопровождаемой.
	4. ЭТАПЫ НОРМАЛИЗАЦИИ
		Процесс нормализации выполняется поэтапно, путём приведения отношений к последовательным нормальным формам.
		1. ПЕРВАЯ НОРМАЛЬНАЯ ФОРМА (1НФ)
			Отношение находится в первой нормальной форме, если:
			- все значения атрибутов являются атомарными;
			- отсутствуют повторяющиеся группы;
			- каждая ячейка таблицы содержит одно значение
			Приведение к 1НФ устраняет составные и многозначные атрибуты.
		2. ВТОРАЯ НОРМАЛЬНАЯ ФОРМА (2НФ)
			Отношение находится во второй нормальной форме, если:
			- оно находится в 1НФ;
			- каждый неключевой атрибут полностью функционально зависит от первичного ключа.
			2НФ устраняет **частичные функциональные зависимости**, возникающие при составных ключах.	
		3. ТРЕТЬЯ НОРМАЛЬНАЯ ФОРМА (3НФ)
			Отношение находится в третьей нормальной форме, если:
			- оно находится в 2НФ;
			- отсутствуют транзитивные зависимости между неключевыми атрибутами
			3НФ устраняет зависимость неключевых атрибутов друг от друга.
		4. НОРМАЛЬНАЯ ФОРМА БОЙСА–КОДДА (BCNF)
			Отношение находится в нормальной форме Бойса–Кодда, если:
			- для каждой нетривиальной функциональной зависимости детерминант является потенциальным ключом.
			BCNF является усилением третьей нормальной формы и обеспечивает более строгую декомпозицию.
		5. ДОПОЛНИТЕЛЬНЫЕ НОРМАЛЬНЫЕ ФОРМЫ
			В реляционном проектировании также рассматриваются:
			- четвёртая нормальная форма (4НФ), устраняющая многозначные зависимости;
			- пятая нормальная форма (5НФ), устраняющая зависимость соединения.
			На практике чаще всего достаточно приведения схемы к **3НФ или BCNF**.
	5. ЭТАПЫ ПРОЕКТИРОВАНИЯ БД С ИСПОЛЬЗОВАНИЕМ НОРМАЛИЗАЦИИ
		1. Анализ предметной области.
		2. Выделение сущностей и их атрибутов.
		3. Определение функциональных зависимостей.
		4. Определение первичных и внешних ключей.
		5. Приведение отношений к 1НФ, 2НФ, 3НФ (при необходимости — BCNF).
		6. Проверка сохранения целостности и связности данных.
	6. ИТОГ
		1. Нормализация является ключевым этапом проектирования реляционных баз данных. Она позволяет получить логически корректную, непротиворечивую и устойчивую структуру БД, минимизирующую избыточность и аномалии операций.
15. Проектирование реляционных БД с использованием нормализации(1НФ, 2НФ, ЗНФ)
	1. Проектирование реляционной базы данных — это процесс логического описания структуры данных, обеспечивающий их корректное хранение, целостность и эффективную обработку. Одним из основных методов проектирования реляционных БД является **нормализация**.
	2. ОПРЕДЕЛЕНИЕ НОРМАЛИЗАЦИИ
		1. Нормализация — это формальный процесс преобразования схемы реляционной базы данных в набор отношений, удовлетворяющих определённым **нормальным формам**, с целью:
			1.  устранения избыточности данных;
			2. предотвращения аномалий обновления;
			3. обеспечения логической целостности данных;
			4. упрощения структуры базы данных.
		2. Нормализация основана на анализе **функциональных зависимостей** между атрибутами отношений.
	3. ФУНКЦИОНАЛЬНЫЕ ЗАВИСИМОСТИ
		1. Функциональная зависимость между атрибутами X и Y записывается как: $X → Y$
			1. Это означает, что значение атрибутов Y однозначно определяется значением атрибутов X.
			2. Нормализация основана на выявлении и анализе таких зависимостей.
	4. ПЕРВАЯ НОРМАЛЬНАЯ ФОРМА (1НФ)
		1. Приведение к 1НФ устраняет составные и повторяющиеся атрибуты и обеспечивает корректное табличное представление данных.
		2. Отношение находится в первой нормальной форме, если:
			1. все значения атрибутов являются **атомарными**;
			2. отсутствуют повторяющиеся группы и многозначные атрибуты;
			3. каждая ячейка таблицы содержит одно значение.
	5. ВТОРАЯ НОРМАЛЬНАЯ ФОРМА (2НФ)
		1. Отношение находится во второй нормальной форме, если:
			1. оно находится в первой нормальной форме;
			2. каждый не ключевой атрибут **полностью функционально зависит** от всего первичного ключа.
		2. 2НФ направлена на устранение **частичных функциональных зависимостей**, которые возникают при наличии составного первичного ключа.
		3. Пример частичной зависимости:
			1. $(A, B) → C$
			2. $A → C$
			3. В этом случае атрибут C зависит только от части ключа, что нарушает 2НФ.
	6. ТРЕТЬЯ НОРМАЛЬНАЯ ФОРМА (3НФ)
		1. Отношение находится в третьей нормальной форме, если:
			1. оно находится во второй нормальной форме;
			2. отсутствуют **транзитивные зависимости** между не ключевыми атрибутами.
		2. Транзитивная зависимость имеет вид:
			1. Z транзитивно зависит от X, если есть Y, для которого выполняются зависимости  $X → Y$ и $Y → Z$, и при этом обратных зависимостей нет, таже можно описать $X → Y→ Z$
		3. В 3НФ каждый не ключевой атрибут должен зависеть **только от первичного ключа и ни от чего больше**.
	7. ПОСЛЕДОВАТЕЛЬНОСТЬ НОРМАЛИЗАЦИИ
		1. Процесс нормализации выполняется поэтапно:
			1. Приведение отношения к 1НФ (устранение неатомарных атрибутов).
			2. Приведение к 2НФ (устранение частичных зависимостей).
			3. Приведение к 3НФ (устранение транзитивных зависимостей).
		2. Каждый следующий этап возможен только после выполнения предыдущего.
	8. ИТОГ
		1. Нормализация до третьей нормальной формы позволяет получить логически корректную структуру реляционной базы данных, свободную от избыточности и аномалий обновления.  
		2. На практике большинство реляционных баз данных проектируются в **3НФ**, что обеспечивает баланс между целостностью данных и эффективностью работы.
16. Проектирование реляционных БД с использованием нормализации (Нормальная форма Бойса-Кодда, 5НФ, 6НФ)
	1. Проектирование реляционных баз данных направлено на построение логически корректной и устойчивой структуры данных. После приведения отношений к третьей нормальной форме (3НФ) в некоторых случаях сохраняются аномалии, связанные с более сложными зависимостями. Для их устранения используются более строгие нормальные формы: **нормальная форма Бойса–Кодда (BCNF)**, **пятая нормальная форма (5НФ)** и **шестая нормальная форма (6НФ)**.
	2. НОРМАЛЬНАЯ ФОРМА БОЙСА–КОДДА (BCNF)
		1. Нормальная форма Бойса–Кодда является усилением третьей нормальной формы.
		2. Отношение находится в **BCNF**, если для любой нетривиальной функциональной зависимости вида  X → Y  детерминант X является **потенциальным ключом** данного отношения. Иными словами, каждый атрибут должен функционально зависеть только от ключей и ни от каких других атрибутов.
		3. BCNF устраняет ситуации, когда отношение формально находится в 3НФ, но всё ещё содержит аномалии обновления из-за функциональных зависимостей, в которых детерминант не является ключом.
		4. На практике приведение к BCNF может приводить к декомпозициям, в которых не всегда сохраняются все функциональные зависимости, поэтому в реальных проектах часто выбирают компромисс между 3НФ и BCNF.
	3. ЧЕТВЕРТАЯ НОРМАЛЬНАЯ ФОРМА (5НФ)
		1. Многозначные зависимости - в отношении R с атрибутами A,B,C существует многозначная зависимость только в том случае, если множество значений В, соответствующих паре значений А и С, зависит только от А и не зависит от С. 
		2. Отношение находится в 4НФ В том и только в том случае, если в случае существования многозначной зависимости A -> -> B все остальные атрибуты R функционально зависят от A. 
		3. Дальнейшая нормализация основывается на теореме Фейджена: отношение R c A,B,C можно спроецировать в два отношения R1 (A,B) и R2 (A,C) только в том случае если есть многозначная зависимость. 
		4. Под проецированием без потерь понимается такой способ декомпозиции отношений, при котором исходное отношение полностью и без избыточности восстанавливается путём естественного соединения полученных отношений.
		5. На практике зависимости, требующие приведения к 4НФ, встречаются редко, поэтому данная нормальная форма используется преимущественно в теоретических и специализированных системах.
	4. ПЯТАЯ НОРМАЛЬНАЯ ФОРМА (5НФ)
		1. Отношение R находится в 5НФ (нормальной форме проекции соединения (PJ/NF)) Только в том случае, когда любая зависимость соединения R следует из существования некоторого возможного ключа в R. Это единственная форма, которая позволяет делить на более чем 2 отношения. 
		2. *Зависимость соединения* - отношение R c атрибутами X,Y,Z удовлетворяют зависимости соединений (X, Y, ..., Z) только в том случае когда R восстанавливается без потерь путём соединения своих проекций на X,Y,Z.
	5. СРАВНЕНИЕ И ПРАКТИЧЕСКОЕ ПРИМЕНЕНИЕ
		1. **BCNF** — практическое усиление 3НФ, устраняет большинство логических аномалий.
		2. **4НФ** — устраняет сложные аномалии, связанные с зависимостями соединения.
		3. **5НФ** — используется в специализированных сценариях, связанных с временными и историческими данными.
		4. В большинстве прикладных систем проектирование ограничивается **3НФ или BCNF**, так как дальнейшая нормализация усложняет структуру БД и увеличивает количество соединений при выполнении запросов.
	6. ИТОГ
		1. Нормальные формы BCNF, 5НФ и 6НФ представляют собой более строгие уровни нормализации, направленные на устранение сложных логических зависимостей. 
		2. Их использование определяется требованиями к целостности данных, характером предметной области и балансом между логической строгостью и производительностью системы.
17. Семантические модели данных
	1. **Семантические модели данных** — это модели данных, ориентированные на описание **смысла (семантики)** предметной области и отражающие реальные объекты, их свойства и взаимосвязи в форме, близкой к человеческому восприятию. Основной целью семантических моделей является **понятное и наглядное представление структуры данных**, независимое от конкретной СУБД и способов физического хранения.
	2. ОБЩАЯ ХАРАКТЕРИСТИКА. Семантические модели:
		1. описывают предметную область на **концептуальном уровне**;
		2. используются на ранних этапах проектирования БД;
		3. служат связующим звеном между пользователями предметной области и разработчиками БД;
		4. не зависят от конкретной логической или физической модели данных.
	3. ОСНОВНЫЕ ПОНЯТИЯ СЕМАНТИЧЕСКИХ МОДЕЛЕЙ
		1. **Сущность**  
			1. Сущность — это объект реального мира, информация о котором должна храниться в базе данных. Сущности могут быть материальными или абстрактными.
		2. **Атрибут**  
			1. Атрибут — это характеристика сущности, описывающая её свойства.
	    3. **Идентификатор (ключ)**  
		    1. Идентификатор — атрибут или набор атрибутов, однозначно определяющий экземпляр сущности.
	    4. **Связь**  
		    1. Связь — это ассоциация между сущностями, отражающая их взаимодействие или зависимость
		 5. **Кратность связей**  
			1. Определяет количество экземпляров одной сущности, связанных с экземплярами другой сущности (один-к-одному, один-ко-многим, многие-ко-многим).
	4. ВИДЫ СЕМАНТИЧЕСКИХ МОДЕЛЕЙ ДАННЫХ
		1. МОДЕЛЬ «СУЩНОСТЬ–СВЯЗЬ» (ER-МОДЕЛЬ)
			1. Наиболее распространённой семантической моделью является **ER-модель**, предложенная Питером Ченом.
			2. В ER-модели используются:
				1. сущности;
				2. атрибуты;
				3. связи;
				4. ключи;
				5. ограничения целостности.
			3. ER-модель применяется для построения **концептуальных схем** базы данных и является основой для дальнейшего перехода к реляционной модели.
	5. РАСШИРЕННЫЕ ER-МОДЕЛИ (EER)
		1. Расширенные ER-модели дополняют классическую ER-модель дополнительными возможностями:
			1. иерархии сущностей (обобщение и специализация);
			2. наследование атрибутов;
			3. агрегация и композиция.
		2. EER-модели позволяют более точно описывать сложные предметные области.
	6. ОБЪЕКТНЫЕ И ОБЪЕКТНО-ОРИЕНТИРОВАННЫЕ МОДЕЛИ
		1. В объектных семантических моделях данные представляются в виде объектов, обладающих:
			1. состоянием (атрибутами);
			2. поведением (методами).
		2. Такие модели используются в объектно-ориентированных СУБД и при проектировании сложных информационных систем.
	7. СЕМАНТИЧЕСКИЕ СЕТИ
		1. Семантические сети представляют данные в виде графов, где:
			1. вершины соответствуют объектам или понятиям;
			2. рёбра — отношениям между ними.
		2. Используются в системах искусственного интеллекта и экспертных системах.
	8. РОЛЬ СЕМАНТИЧЕСКИХ МОДЕЛЕЙ В ПРОЕКТИРОВАНИИ БД
		1. Семантические модели применяются:
			1. на этапе анализа предметной области;
			2. для построения концептуальной схемы БД;
			3. как основа для перехода к логической модели (например, реляционной);
			4. для выявления ограничений и связей, неявных на уровне таблиц.
	9. ПРЕИМУЩЕСТВА СЕМАНТИЧЕСКИХ МОДЕЛЕЙ
		1. наглядность и понятность;
		2. близость к предметной области;
		3. независимость от реализации;
		4. снижение количества ошибок при проектировании.
	10. НЕДОСТАТКИ
		1. невозможность непосредственного хранения данных;
		2. необходимость преобразования в логическую модель;
		3. отсутствие формального аппарата выполнения запросов.
	11. ИТОГ
		1. Семантические модели данных предназначены для концептуального описания предметной области и служат основой для дальнейшего логического проектирования баз данных.  
		2. Они обеспечивают корректное понимание структуры данных и связей между ними до перехода к конкретной СУБД.
18. Основные понятия ER- модели
	1. **ER-модель (Entity–Relationship, модель «сущность–связь»)** — это семантическая модель данных, предназначенная для концептуального описания предметной области в терминах сущностей, их атрибутов и связей между ними.  
	2. ER-модель используется на этапе **концептуального проектирования** базы данных и не зависит от конкретной СУБД.
	3. СУЩНОСТЬ (Entity) (лекция)
		1. **Сущность** — это объект реального или абстрактного мира, информация о котором должна храниться в базе данных и быть доступна. В диаграммах представлена в виде прямоугольника.
		2. Характеристики сущности:
			1. имеет смысловое значение в предметной области;
			2. может существовать независимо;
			3. описывается набором атрибутов.
			4. Примеры сущностей: студент, заказ, товар, сотрудник.
		3. ЭКЗЕМПЛЯР СУЩНОСТИ
			1. **Экземпляр сущности** — это конкретное представление сущности, соответствующее одному объекту реального мира. Должен быть отличим от любого другого экземпляра той же сущности
			2. Например, один конкретный студент с определённым номером зачётной книжки.
	4. СВЯЗЬ (Relationship) (лекция)
		1. **Связь** — это графически изображаемая ассоциация, устанавливаемая между двумя сущностями. Эта ассоциация всегда является бинарной (между двумя сущностями) и может существовать между двумя разными сущностями или между сущностью и ей же самой (рекурсивная связь)
		2. Связь также может иметь собственные атрибуты.
		3. КРАТНОСТЬ СВЯЗИ (Кардинальность)
			1. **Кратность связи** определяет, сколько экземпляров одной сущности может быть связано с экземплярами другой сущности.
			2. Основные виды кратности:
				1. один к одному (1:1);
				2. один ко многим (1:N);
				3. многие ко многим (M:N).
			3. Кратность является важным ограничением целостности.
		4. ОБЯЗАТЕЛЬНОСТЬ УЧАСТИЯ (Participation)
				1. Определяет, обязательно ли участие экземпляра сущности в связи.
				2. Различают:
					1. полное участие (каждый экземпляр участвует в связи);
					2. частичное участие (участие необязательно).
	5. АТРИБУТ (Attribute) (лекция)
		1. **Атрибут** — это характеристика сущности, описывающая её свойства.
		2. Свойства атрибутов:
			1. заполняются внутри прямоугольников, с малой буквы, возможно с примерами
			2. имеют имя;
			3. принимают значения из определённого домена;
			4. являются атомарными (в классической ER-модели).
	6. КЛЮЧ (Уникальный идентификатор типа сущности) (лекция)
		1. **Ключ** — это атрибут или набор атрибутов, однозначно идентифицирующий экземпляр сущности. Только из тех атрибутов, что доступны при построении модели, добавлять ничего нельзя.
		2. Свойства ключа:
			1. уникальность;
			2. минимальность.
		3. В ER-модели выделяют:
			1. потенциальные ключи;
			2. первичный ключ (выбранный идентификатор).
	7. НОРМАЛЬНЫЕ ФОРМЫ
		1. *1 НФ* - Устраняются атрибуты, содержащие множественные значения, то есть производится выявление неявных сущностей, "замаскированных" под сущности.
		2. *2 НФ* - устраняются атрибуты, зависящие только от части уникального идентификатора. Эта часть уникального идентификатора определяет отдельную сущность .
		3. *3 НФ* - устраняются атрибуты, зависящие от атрибутов, не входящих в уникальный идентификатор. Эти атрибуты являются основой отдельной сущности.
	8. РОЛЬ ER-МОДЕЛИ
		1. ER-модель:
			1. отражает семантику предметной области;
			2. служит основой для логического проектирования;
			3. используется для перехода к реляционной модели данных;
			4. упрощает взаимодействие между аналитиками и разработчиками.
	9. ИТОГ
		1. ER-модель использует понятия сущностей, атрибутов, связей и ключей для наглядного и формального описания предметной области. Она является основным инструментом концептуального проектирования реляционных баз данных.
19. Получение реляционной схемы из ER-схемы
	1. Получение реляционной схемы из ER-схемы — это процесс преобразования концептуальной модели данных в логическую реляционную модель, пригодную для реализации в реляционной СУБД.
	2. Основные правила преобразования:
		1. **Сущность → таблица**  
			1. Имя сущности - имя таблицы
			2. Для каждой сущности ER-модели создаётся отдельная таблица.  
			3. Простые атрибуты → столбцы.
		2. **Идентификатор сущности → первичный ключ**  
			1. Ключ сущности преобразуется в первичный ключ таблицы.
		3. **Составные атрибуты**  
			1. Разбиваются на простые атрибуты и реализуются отдельными столбцами.
		4. **Связь 1:1**  
			1. Реализуется добавлением внешнего ключа в одну из таблиц или объединением таблиц.
		5. **Связь 1:N**
			1. Первичный ключ сущности со стороны «1» добавляется как внешний ключ в таблицу сущности со стороны «N».
		6. **Связь M:N**  
			1. Реализуется созданием отдельной таблицы, содержащей внешние ключи на обе сущности и, при необходимости, атрибуты связи.
		7. **Слабая сущность** 
			1. Таблица слабой сущности содержит внешний ключ на сильную сущность и частичный ключ; вместе они образуют составной первичный ключ.
	3. В результате получается реляционная схема, готовая к нормализации и физической реализации.
20. Ограничение целостности модели данных (Основные понятия, виды целостности и целостность по ссылкам)
	1. **Целостность данных** — это свойство базы данных сохранять корректность, непротиворечивость и согласованность данных при выполнении всех операций.
	2. **Ограничения целостности** — это правила, определяющие допустимые состояния данных и предотвращающие появление ошибок.
	3. Основные виды целостности данных:
		1. Целостность сущностей
			1. Требует, чтобы:
				1. каждая таблица имела первичный ключ;
				2. значение первичного ключа было уникальным;
				3. значение первичного ключа не могло быть NULL.
			2. Целостность сущностей обеспечивает однозначную идентификацию каждой строки таблицы.
		2. Целостность по ссылкам (ссылочная целостность)
			1. Целостность по ссылкам определяет корректность связей между таблицами.
			2. Основные требования:
				1. значение внешнего ключа должно либо ссылаться на существующее значение первичного ключа в связанной таблице, либо быть NULL;
				2. запрещается появление «висячих ссылок».
			3. При изменении или удалении записей применяются правила:
				1. запрет операции;
				2. каскадное обновление;
				3. каскадное удаление;
				4. установка значения NULL или по умолчанию.
			4. Ссылочная целостность обеспечивает согласованность связанных данных.
		3. Доменная целостность
			1. Ограничивает допустимые значения атрибутов типами данных, диапазонами значений и форматами.
	4. Помимо встроенных видов целостности, в модели данных используются **пользовательские ограничения целостности** 
21. Ограничение целостности модели данных (Основные понятия, виды целостности и целостность, определяемая пользователем)
	1. 1. **Целостность данных** — это свойство базы данных сохранять корректность, непротиворечивость и согласованность данных при выполнении всех операций.
	2. **Ограничения целостности** — это правила, определяющие допустимые состояния данных и предотвращающие появление ошибок.
	3. Основные виды целостности данных:
		1. Целостность сущностей
			1. Требует, чтобы:
				1. каждая таблица имела первичный ключ;
				2. значение первичного ключа было уникальным;
				3. значение первичного ключа не могло быть NULL.
			2. Целостность сущностей обеспечивает однозначную идентификацию каждой строки таблицы.
		2. Целостность по ссылкам (ссылочная целостность)
			1. Целостность по ссылкам определяет корректность связей между таблицами.
			2. Основные требования:
				1. значение внешнего ключа должно либо ссылаться на существующее значение первичного ключа в связанной таблице, либо быть NULL;
				2. запрещается появление «висячих ссылок».
			3. При изменении или удалении записей применяются правила:
				1. запрет операции;
				2. каскадное обновление;
				3. каскадное удаление;
				4. установка значения NULL или по умолчанию.
			4. Ссылочная целостность обеспечивает согласованность связанных данных.
		3. Доменная целостность
			1. Ограничивает допустимые значения атрибутов типами данных, диапазонами значений и форматами.
	4. Помимо встроенных видов целостности, в модели данных используются **пользовательские ограничения целостности** :
		1. **Целостность, определяемая пользователем**, — это ограничения, задаваемые в соответствии с правилами предметной области, которые не могут быть полностью выражены стандартными средствами модели данных.
		2. К пользовательским ограничениям относятся:
			1. логические условия, зависящие от смысла данных;
			2. бизнес-правила;
			3. ограничения, связывающие несколько атрибутов или таблиц.
		3. Примеры:
			1. дата окончания должна быть позже даты начала;
			2. сумма заказа не может быть отрицательной;
			3. сотрудник может быть назначен руководителем только одного отдела;
			4. возраст клиента должен быть больше определённого значения.
		4. Такие ограничения реализуются:
			1. проверочными условиями;
			2. триггерами;
			3. хранимыми процедурами;
			4. прикладной логикой.
		5. Пользовательская целостность дополняет доменную, сущностную и ссылочную целостность и обеспечивает соответствие базы данных реальным правилам предметной области.
22. Реляционная модель данных (достоинства и недостатки)
	1. Недостатки:
		1. Ограниченность (из-за простоты) при использовании в нетрадиционных областях (например САПР), в которых требуются предельно сложные структуры данных.
		2. Невозможность адекватного отражения семантики (возможности представления знаний о семантической специфики предметной области в реляционных системах очень ограничены)
		3. Низкая производительность при сложных соединениях- операции соединения больших таблиц могут быть ресурсоёмкими и снижать производительность.
		4. Необходимость нормализации - Процесс проектирования требует анализа функциональных зависимостей и может быть трудоёмким.
		5. Проблемы масштабирования - Горизонтальное масштабирование реляционных БД сложнее по сравнению с некоторыми нереляционными моделями.
	2. Достоинства :
		1. Простота и наглядность представления данных - данные представлены в виде таблиц, что интуитивно понятно пользователям и разработчикам.
		2. Строгая теоретическая основа - Реляционная модель опирается на теорию множеств, реляционную алгебру и реляционное исчисление, что обеспечивает формальную корректность операций над данными.
		3. Логическая и физическая независимость данных - Изменения в физическом хранении данных не требуют изменения логической структуры и прикладных программ.
		4. Поддержка целостности данных - Модель позволяет задавать ограничения целостности: сущностную, ссылочную, доменную и пользовательскую.
		5. Отсутствие избыточности при нормализации - Использование нормальных форм снижает дублирование данных и предотвращает аномалии обновления.
		6. Гибкость запросов - Реляционные языки запросов (например, SQL) позволяют выполнять сложные выборки без знания физической организации данных.
		7. Стандартизация и широкая распространённость - Реляционная модель лежит в основе большинства современных СУБД и имеет международные стандарты.
23. Сетевая модель данных
	1. **Сетевая модель данных** — это логическая модель данных, в которой информация представляется в виде **графа**, состоящего из узлов и связей. Узлы соответствуют записям (объектам данных), а связи отражают отношения между ними. Сетевая модель является развитием и обобщением иерархической модели данных.
	2. ОСНОВНЫЕ ПОНЯТИЯ СЕТЕВОЙ МОДЕЛИ
		1. **Запись** — основная единица хранения данных, содержащая набор полей. Аналог строки таблицы в реляционной модели.
		2. **Поле** — элемент записи, хранящий отдельное значение.
		3. **Тип записи** — описание структуры записи, включающее перечень полей.
		4. **Набор (set)** — основной механизм связи в сетевой модели. Набор представляет собой связь между двумя типами записей:
			1. **владелец (owner)**;
			2. **член (member)**.
		5. Один владелец может быть связан с несколькими членами, а одна запись-член может принадлежать нескольким наборам.
	3. СТРУКТУРА СЕТЕВОЙ МОДЕЛИ
		1. В сетевой модели:
			1. данные организованы в виде сети (ориентированного графа);
			2. допускаются связи типа «многие ко многим»;
			3. одна запись может иметь несколько владельцев;
			4. связи между записями задаются явно и фиксируются в структуре базы данных.
		2. Классическим формальным описанием сетевой модели является стандарт **CODASYL**.
	4. ОПЕРАЦИИ ДОСТУПА К ДАННЫМ
		1. Доступ к данным в сетевой модели осуществляется **навигационным способом**, то есть путём последовательного перехода от одной записи к другой по заданным связям.
		2. Основные операции:
			1. переход от владельца к члену набора;
			2. переход между связанными записями;
			3. вставка, удаление и обновление записей с учётом связей.
		3. Запросы требуют точного знания структуры базы данных и путей навигации.
	5. ДОСТОИНСТВА СЕТЕВОЙ МОДЕЛИ
		1. **Высокая производительность** - Явно заданные связи обеспечивают быстрый доступ к связанным данным.
		2. **Поддержка сложных связей** - Сетевая модель естественно поддерживает отношения типа «многие ко многим».
		3. **Гибкость структуры по сравнению с иерархической моделью** - Одна запись может иметь несколько владельцев.
		4. **Эффективность при навигационном доступе** - Хорошо подходит для приложений с заранее известными маршрутами доступа к данным.
	6. НЕДОСТАТКИ СЕТЕВОЙ МОДЕЛИ
		1. **Сложность проектирования и сопровождения** - Структура базы данных сложна для понимания и изменения.
		2. **Сильная зависимость программ от структуры данных**  - Изменение схемы требует изменения прикладных программ.
		3. **Отсутствие логической независимости данных** - Навигационные запросы жёстко привязаны к структуре БД.
		4. **Сложность формулирования запросов** - Пользователь должен знать все пути доступа к данным.
		5. **Отсутствие развитого формального аппарата запросов** - По сравнению с реляционной моделью, сетевая модель менее формализована.
24. Иерархическая модель данных
	1. **Иерархическая модель данных** — это логическая модель данных, в которой информация организована в виде **дерева**. Данные представлены в виде узлов, связанных отношениями типа «родитель–потомок». Каждый потомок имеет только одного родителя, а корневой узел не имеет родителей.
	2. ОСНОВНЫЕ ПОНЯТИЯ ИЕРАРХИЧЕСКОЙ МОДЕЛИ
		1. **Узел** — основной элемент иерархической структуры, представляющий запись данных.
		2. **Корневой узел** — верхний узел иерархии, не имеющий родителя.
		3. **Родительский узел** — узел, который связан с подчинёнными узлами.
		4. **Дочерний узел** — узел, подчинённый родительскому.
		5. **Тип записи** — описание структуры узла, включающее набор полей.
		6. **Связь** — отношение между родительским и дочерним узлами, отражающее подчинённость данных.
	3. СТРУКТУРА ИЕРАРХИЧЕСКОЙ МОДЕЛИ
		1. В иерархической модели:
			1. каждый узел, кроме корневого, имеет ровно одного родителя;
			2. один родитель может иметь множество потомков;
			3. структура данных представляет собой ориентированное дерево;
			4. связи между узлами фиксированы и жёстко заданы.
			5. Связи типа «многие ко многим» напрямую не поддерживаются.
	4. ДОСТУП К ДАННЫМ
		1. Доступ к данным осуществляется **навигационным способом**:
			1. переход от корня к нужному узлу;
			2. последовательный обход иерархии;
			3. заранее заданные пути доступа.
			4. Для получения данных необходимо знать структуру дерева и порядок переходов.
	5. ДОСТОИНСТВА ИЕРАРХИЧЕСКОЙ МОДЕЛИ
		1. **Простота структуры** - Деревовидная организация данных легко воспринимается и понимается.
		2. **Высокая производительность** - Навигационный доступ обеспечивает быстрый переход между связанными данными.
		3. **Эффективность для строго иерархических данных** - Хорошо подходит для данных с естественной подчинённостью.
		4. **Минимальные накладные расходы** - Простая структура хранения и доступа.
	6. НЕДОСТАТКИ ИЕРАРХИЧЕСКОЙ МОДЕЛИ
		1. **Жёсткость структуры** - Изменение иерархии требует переработки базы данных и приложений.
		2. **Отсутствие поддержки связей “многие ко многим”** - Такие связи приходится моделировать искусственно.
		3. **Зависимость приложений от структуры данных** - Отсутствует логическая независимость данных.
		4. **Сложность выполнения произвольных запросов** - Доступ возможен только по заранее определённым путям.
25. Сравнение сетевой и иерархической моделей данных
	1. **Иерархическая и сетевая модели данных** относятся к навигационным моделям и являются исторически первыми подходами к организации баз данных. Обе модели основаны на явном задании связей между данными и предполагают навигационный доступ к информации.
	2. Структура данных
		1. **Иерархическая модель** организует данные в виде дерева. Каждый элемент (узел) имеет одного родителя и может иметь несколько потомков. Связи типа «многие ко многим» напрямую не поддерживаются.
		2. **Сетевая модель** организует данные в виде графа. Один элемент может иметь несколько владельцев, что позволяет напрямую реализовывать связи «многие ко многим».
	3. Типы связей
		1. В иерархической модели поддерживаются только связи типа:
			1. один ко многим (1:N).
		2. В сетевой модели поддерживаются:
			1. один ко многим (1:N);
			2. многие ко многим (M:N).
	4. Способ доступа к данным
		1. Обе модели используют **навигационный способ доступа**:
			1. переход от одной записи к другой по заранее заданным связям;
			2. необходимость знания структуры базы данных и путей доступа.
		2. Однако в иерархической модели путь доступа строго определяется структурой дерева, а в сетевой модели возможны альтернативные маршруты перехода.
	5. Гибкость структуры
		1. **Иерархическая модель** обладает жёсткой структурой. Изменение структуры дерева требует значительной переработки базы данных и приложений.
		2. **Сетевая модель** более гибкая, так как допускает несколько связей для одной записи, но при этом сложнее в проектировании и сопровождении.
	6. Производительность
		1. Обе модели обеспечивают высокую производительность при навигационном доступе. Сетевая модель, как правило, эффективнее при сложных взаимосвязях между данными, тогда как иерархическая модель эффективна для строго иерархических структур.
	7. Зависимость программ от данных
		1. В обеих моделях прикладные программы сильно зависят от структуры базы данных.  
		2. Отсутствует логическая независимость данных, что усложняет сопровождение и развитие системы.
	8. Сложность использования
		1. **Иерархическая модель** проще для понимания и реализации, но ограничена по возможностям.
		2. **Сетевая модель** более выразительна, но сложнее для проектирования, администрирования и использования.
	9. Итог
		1. Иерархическая модель данных проста и эффективна для строго иерархических структур, но ограничена в выразительности.
		2. Сетевая модель данных более гибкая и мощная, однако сложна в проектировании и сопровождении.  
		3. Именно сочетание жёсткости и сложности сетевой модели привело к их вытеснению реляционной моделью данных в большинстве современных систем.
26. Даталогическое моделирование
	1. **ДЛМ**
		1. Допустимое представление данных с помощью определённых программно-технических средств, то есть ДЛМ должна быть всегда ориентирована на среду реализации. Из этого следует, что большое разнообразие программно-технических средств предполагает разнообразие даталогических моделей. 
	2. **Программно-техническая среда (ПТСр)** - это совокупность следующих факторов:
		1. Типохарактеристика информационного пространства
		2. Типохарактеристика вычислительной техники
		3. Типохарактеристика ОС. Пакет программ, предназначенных для выполнения определенных функций по обработке различных видов информации. 
	3. **Программно-технические средства (ПТС)** - это пакет или комплекс программ, предназначенный для выполнения специфических функций и встраиваемый в определенную программно-техническую среду. 
	4. **СУБД** - это совокупность языковых и программных средств предназначенных для создания, ведения и использования БЛ многими пользователями.  СУБД объединяет 2 идеи:
		1. Идея структуризации данных
		2. Централизация хранения информации и децентрализация использования ее
		3. Каждая **СУБД** поддерживает определенное модельное представление информации, которое называется даталогическое представление СУБД. После этапа выбора программно-технических средств следует создание даталогической модели предметной задачи, ориентированной на выбранную СУБД.
	5. Под **ДЛМ предметной задачи ($ДЛМ_{пз}$)** понимают совокупность структур данных и алгоритмов программ на эти структуры, обеспечивающих автоматизированное решеине предметной задачи.
	6. **Организация решения** - Это организация представления данных и организация технических средств
27. Структура ДЛМ
	1. ДЛМ строится на 2 уровнях:
	2. Логический
		1. Обобщенный уровень - концептуальная модель
			1. Концептуальная модель: Информационная модель предметной области в терминах конкретной СУБД, содержащая полный набор данных.
		2. Локальный уровень - внешняя модель
			1. Внешняя модель: В архитектуре СУБД модель данных на внешнем уровне отображает представление пользователя о БД 
	3. Физический
		1. Обобщенный уровень - внутренняя модель
			1. В архитектуре СУБД слой нижнего физического уровня отображающий представление данных во внешней памяти и методы доступа к нему.
		2. (Не из лекции) Локальный уровень - физические структуры хранения
			1. Этот уровень отвечает за реальное физическое хранение и эффективность доступа.
	4. Даталогическая модель данных имеет логический и физический уровни. Каждый из них включает обобщённый и локальный подуровни: на логическом уровне — концептуальную и внешнюю модели, а на физическом уровне — внутреннюю модель и локальные физические структуры хранения.
28. Языки ДЛМ
	1. Так как ДЛМ должна отображать описание данных и манипулирование ими, то язык ДЛМ разделяется на:
		1. ЯОД(язык описания данных)
			1. **Язык описания данных** предназначен для задания структуры базы данных.
			2. ЯОД формирует логическую схему базы данных
			3. С помощью DDL:
				1. описываются схемы базы данных;
				2. задаются структуры отношений (таблиц);
				3. определяются атрибуты и их типы;
				4. задаются первичные и внешние ключи;
				5. описываются связи между данными.
		2. ЯМД(язык манипулирования данными)
			1. **Язык манипулирования данными** используется для выполнения операций над данными.
			2. С его помощью выполняются:
				1. выборка данных;
				2. вставка новых записей;
				3. обновление существующих данных;
				4. удаление данных.
			3. Манипуляционная часть ДЛМ в реляционной модели базируется на:
				1. реляционной алгебре;
				2. реляционном исчислении.
29. Задача выбора программно-технических средств для реализации автоматизированной информационной системы
	1. **Постановка задачи** фактически аналогична задаче выбора технологического оборудования для изготовления детали по чертежу
	2. **Исходная информация** для решения задачи выбора ПТС включает следующее описание:
		1. Информационная модель представляет собой совокупность информационной структуры (то есть определенной организации данных) и алгоритм решения задачи на этой структуре(то есть действия по обработке, доступу и фиксации данных)
		2. Ограничения или условия, связанные с эксплуатацией автоматизированной системы
		3. Документация по различным СУБД(описание характеристики ПТ средств)
	3. **Цель задачи**: необходимо выбрать наилучшую СУБД в соответствии с критерием: минимум затрат на разработку, реализацию и эксплуатацию АИС для нашей предметной области с использованием нашей СУБД. При этом выбранное ПТСр-во должно полностью реализовывать все функции, отраженные в алгоритме
	4. Особенности решения задачи:
		1. неполнота исходной информации
		2. многоаспектность сравниваемых альтернатив.
	5. Метод решения задачи выбора ПТС(программно-технических средств) может включать в себя несколько итераций, каждая из которых состоит из 2 этапов: качественный и количественный анализ.
		1. Качественный. Суть заключается в определении качественного соответствия наших требований и существующих возможностей (соотношение информационной модели и выбранной СУБД)
		2. Количественный. Суть заключается в определении степени этого соответствия
	6. На этапе качественного анализа выполняется формирование параметров для описания информационной модели предметной задачи и ограничений на ее эксплуатацию и качественное сравнение параметров задачи и СУБД, при этом получают качественную оценку пригодности СУБД(подходит-не подходит). Если результатом этого этапа является значительное количество СУБД, то целесообразно проанализировать их более подробно.
	7. На этапе количественного анализа формируется шкала (диапазон) параметров для описаний предметной задачи и проводится оценка степени соответствия требований предметной задачи возможностям отобранных СУБД, то есть проводят многокритериальную оценку пригодности СУБД. 
30. Схема параметризации исходной информации задачи
	1. **Схема параметризации исходной информации задачи** — это формализованное описание всех входных данных предметной области, необходимых для решения задачи, представленное в виде совокупности параметров, их характеристик и взаимосвязей. Параметризация позволяет перейти от неструктурированного описания предметной области к формальному представлению данных, пригодному для построения информационной системы и базы данных.
	2. При описании ПТСр выделяют три уровня:
		1. **Внешний по отношению к этому ПТСредству**. К этому уровню относятся: класс вычислительной техники, операционные среды, взаимодействие с периферийным оборудованием и настройка. Группа параметров: **внешние параметры**
		2. **Описание содержимого ПТСредства**. Относятся: Виды интерфейса для выполнения основных функций по обработке информации, спектр дополнительных функций для обработки информации. Группа параметров: **Внутренние функциональные параметры(функции составляющие алгоритм "обработки проекта"**
		3. **Внутренний - содержание ПТСредства**. Относятся: Описание структуры и особенности ДЛМ, поддерживаемой данными ПТСредствами(состав структурных единиц для хранения, представления, обработки информации, количественная оценка структурных единиц и связей между ними). Группа параметров: **Внутренние структурные параметры**
	3. ОСНОВНЫЕ ЭЛЕМЕНТЫ СХЕМЫ ПАРАМЕТРИЗАЦИИ
		1. Схема параметризации включает следующие компоненты
		2. Параметры задачи
			1. **Параметр** — это элементарная характеристика объекта или процесса предметной области, принимающая конкретные значения.
			2. Для каждого параметра задаются:
			3. наименование;
			4. смысловое описание;
			5. тип данных;
			6. допустимая область значений (домен).
		3. Типы параметров
			1. Параметры классифицируются по назначению:
			2. **идентификационные** — однозначно определяют объект (идентификаторы);
			3. **описательные** — характеризуют свойства объекта;
			4. **управляющие** — влияют на ход решения задачи;
			5. **временные** — отражают временные характеристики процессов.
		4. Домены параметров
			1. **Домен** — это множество допустимых значений параметра.
			2. Для каждого параметра определяется:
			3. тип данных;
			4. диапазон значений;
			5. ограничения допустимости.
			6. Домены обеспечивают контроль корректности вводимой информации.
		5. Связи между параметрами
			1. Между параметрами могут существовать:
			2. функциональные зависимости;
			3. логические ограничения;
			4. иерархические или ассоциативные связи.
			5. Связи отражают семантику предметной области и используются при построении ER-модели.
		6. Группировка параметров
			1. Параметры объединяются в группы, соответствующие:
			2. объектам предметной области;
			3. событиям;
			4. процессам.
			5. Такая группировка является основой для выделения сущностей и атрибутов.
		7. РОЛЬ СХЕМЫ ПАРАМЕТРИЗАЦИИ В ПРОЕКТИРОВАНИИ БД
			1. Схема параметризации:
			2. предшествует построению ER-модели;
			3. используется для выявления сущностей, атрибутов и связей;
			4. обеспечивает переход от предметной области к формальной модели данных;
			5. снижает вероятность логических ошибок проектирования.
		8. ИТОГ
			1. Схема параметризации исходной информации задачи представляет собой формализованное описание параметров предметной области, их доменов и взаимосвязей, служащее основой для последующего построения концептуальной, логической и физической моделей базы данных.
31. Организация интерфейса пользователя СУБД
	1. Интерфейс СУБД делят на 2 вида - это *программный* и *диалоговый*
	2. Программный 
		1. процедурный
			1. ЯМДиЯП
			2. транслятор типа интерпретатор/ транслирует и выполняет построчно.
			3. dBase
		2. программный
			1. В ЯП вставлены команды ЯМД
			2. компилятор 
			3. CAL-интерфейс
			4. пошаговая компиляция
	3. Диалоговый позволяет: 
		1. манипулировать любыми структурными единицами
		2. вспомогательные компоненты - информационно-справочный блок 
		3. системы команд
	4. Особенности CAL- интерфейса: 
		1. В тексте программы на определенном ЯП фиксируется обращение к функциям и процедурам, которые являются компонентами СУБД.
		2. Обмен данными между программой и СУБД – это замещение формальных параметров фактическими.
		3. При компиляции такой программы необходимо подключать соответствующую библиотеку.
32. Критерии реляционности СУБД
	1. Реляционная БД должна обеспечивать доступ к данным на логическом уровне, а не на физическом
	2. Выбор данных должен происходить по именам и значениям без явного перемещения по записям
	3. Не пользователь-программист, а система должна выбирать наилучший способ выполнения запроса 
	4. Полный набор реляционных операций должен происходить как над исходными записями так и над совокупностью записей в результате запроса.
	5. Из гпт
		1. Замкнутость операций относительно отношений - Результатом выполнения любой операции над данными должно быть **отношение**.
		2. Поддержка целостности данных
			1. Реляционная СУБД должна обеспечивать:
			2. доменную целостность;
			3. целостность сущностей (первичные ключи);
			4. ссылочную целостность (внешние ключи);
			5. пользовательские ограничения целостности.
			6. Ограничения целостности должны поддерживаться на уровне СУБД, а не только прикладных программ. Это свойство обеспечивает композиционность запросов и возможность построения сложных выражений.
		3. Логическая независимость данных - Изменения логической структуры базы данных (например, добавление атрибутов) не должны приводить к необходимости изменения прикладных программ.
		4. Физическая независимость данных - Изменения способов физического хранения данных не должны влиять на логическую модель и запросы пользователей.
		5. Унифицированный механизм обновления данных - Все операции над данными (вставка, удаление, обновление) должны выполняться через единый реляционный механизм и быть применимы к любым отношениям.
		6. Независимость от навигации - Доступ к данным не должен требовать знания путей перехода между записями. Любые данные должны быть доступны через логические запросы.
		7. КРИТЕРИИ КОДДА (В ОБЩЕМ ВИДЕ) - Совокупность этих требований часто называют **критериями Кодда**. Полное соответствие всем критериям на практике встречается редко, однако чем больше критериев выполняет СУБД, тем выше степень её реляционности
33. Реализация автоматизированных информационных систем
	1. Этапы 
		1. Организация вычислительной среды
		2. Организация вычислительного процесса
		3. Опытная эксплуатация
		4. Доработка автоматизированного продукта
		5. Ввод в эксплуатацию 
	2. Проблематика
		1. Проблема наращивания данных
		2. Проблем, связанная с распределенностью данных
		3. Проблема репликации данных
	3. **Основные понятия модели «клиент-сервер»**
		1. Говоря о сервере базы данных, подразумевают как компьютер, так и программное обеспечение - ядро СУБД. При описании архитектуры "клиент-сервер" под сервером базы данных имеется в виду компьютер.
	4. Физическое представление:
		1. Компьютер, управляющий определенным ресурсом, принято называть **сервером этого ресурса**, а компьютер, желающий им воспользоваться - **клиентом**. Сервер должен обладать ресурсами, соответствующими его функциональному назначению и потребностям сети. Этот же принцип распространяется и на взаимодействие программ. Если программа выполняет некоторые функции, предоставляя другим программам соответствующий набор услуг, то она рассматривается в качестве **сервера**. Программы, которые пользуются этими услугами, называют **клиентами**.
	5. **Варианты технологической реализации АИС** 
		1. Основной принцип заключается в разделении функций СУБД на три группы, имеющие различную природу.
			1. *Первая группа* - это функции ввода и отображения данных. 
			2. Вторая группа объединяет чисто прикладные функции, характерные для данной предметной области (например, для банковской системы - открытие счета, перевод денег с одного счета на другой и т.д.).
			3. К третьей группе  относятся фундаментальные функции хранения и управления информационными ресурсами (базами данных, файловыми системами и т.д.).
		2. В соответствии с этим в любой СУБД выделяются следующие логические компоненты:
			1. Компонент интерфейса (компонент представления);
			2. Прикладной компонент;
			3. Компонент доступа к БД;
		3. Выделяются четыре подхода, реализованные в следующих моделях:
			1. модель файлового сервера (File Server - FS);
			2. модель доступа к удаленным данным (Remote Data Access - RDA);
			3. модель севера базы данных (DataBase Server - DBS);
			4. модель сервера приложений (Application Server - AS).
34. Отличительная особенность традиционного подхода к реализации АИС, проблема наращивания данных.
	1. Варианты технологической реализации АИС
	2. Основной принцип заключается в разделении функций СУБД на три группы, имеющие различную природу. 
		1. Первая группа - это функции ввода и отображения данных.
		2. Вторая группа объединяет чисто прикладные функции, характерные для данной предметной области (например, для банковской системы - открытие счета, перевод денег с одного счета на другой и т.д.).
		3. К третьей группе относятся фундаментальные функции хранения и управления информационными ресурсами (базами данных, файловыми системами и т.д.). 
	3. В соответствии с этим в любой СУБД выделяются следующие логические компоненты:
		1. Компонент интерфейса (компонент представления);
		2. Прикладной компонент; 
		3. Компонент доступа к БД;
	4. Выделяются четыре подхода, реализованные в следующих моделях:
		1. модель файлового сервера (File Server - FS);
		2. модель доступа к удаленным данным (Remote Data Access - RDA);
		3. модель севера базы данных (DataBase Server - DBS);
		4. модель сервера приложений (Application Server - AS).
	5. Проблема наращивания данных связана с увеличением информационной емкости БД: 
		1. Значительное увеличение объема данных. Это происходит при работе разных пользователей с одной БД. 
		2. Устаревание и потеря актуальности исторических данных. Это происходит из-за изменения тенденций, которые этим данным соответствуют.
		3. Рассинхронизация данных. Копии данных могут мигрировать из разных источников по разным графикам и с разной скоростью. В результате они легко рас синхронизируются с исходными системами, что затрудняет создание единой версии “правды” и приводит к возможности ошибочного анализа данных. 
	6. Для решения проблемы наращивания данных можно, например, использовать сервисы, которые автоматизируют и ускоряют синхронизацию данных, а также сервисы для архивирования и репликации данных.
	7. Репликация данных – процесс копирования и синхронизации данных на нескольких серверах. Цель - обеспечить высокую доступность данных.
	8. Синхронизация данных – одновременное изменение данных во всех частях
35. Отличительная особенность традиционного подхода к реализации АИС, проблема распределенности данных
	1. Проблема, связанная с распределенностью данных – анализ вариантов технологической реализации АИС с учетом видов компонент. 1
	2. 2 правил Кристофера Дейта для систем распределенных баз данных, в которых данные хранятся и обрабатываются на нескольких взаимосвязанных узлах, чтобы гарантировать надежность, согласованность и эффективность 
		1. Независимость распределения - распределение данных не должно влиять на приложения, использующие распределённую БД.
		2. Локальная автономность - каждое местоположение или узел должно отвечать за свои собственные данные
		3. Непрерывная работа - распределённые БД должны прилагать все усилия для продолжения работы в условиях ошибок или сбоев в сети. (репликация, резервное копирование)
		4. Независимость от местоположения - местоположение данных должно быть понятно пользователям и приложениям в соответствии с правилом независимости от местоположения.
		5. Независимость от фрагментации - БД фрагментируется, когда она разбивается на более мелкие части или фрагменты и распределяется по нескольким узлам.
		6. Независимость репликации - репликация подразумевает создание и хранения копий данных на других узлах. Это правило гласит, что программы должны иметь возможность получать доступ к данным и изменять их, избегая реплицированные экземпляры
		7. Распределённая обработка запросов - оптимизация и выполнение запросов в распределённой системе БД являются основным темами распределённой обработки запросов. Запросы должны быть способны эффективно обрабатываться и выполняться в нескольких узлах.
		8. Распределённая обработка транзакций - поддержание согласованности и целостности данных в распределённых транзакциях является основной задачей распределённой обработки транзакций. Они должны соответствовать критериям ACID (атомарность, согласованность, изоляция, надежность)
		9. Независимость от аппаратного обеспечения - распределённая система БД должна быть независима от базовой аппаратной инфраструктуры в соответствии с правилом независимости от аппаратного обеспечения. Приложения должны иметь возможность взаимодействовать с системой БД без ограничений, связанных с конкретными характеристиками аппаратного обеспечения
		10. Независимость от ОС - правило гласит, что распределённая система БД должна быть независима от конкретных ОС, на которых она работает. 
		11. Независимость от сети - подчёркивает необходимость того, чтобы распределённая БД была независима от базовой сетевой инфраструктуры, сетевых протоколов или технологий.
		12. Независимость от центральных служб - согласно окончательному руководству, распределённая БД не должна зависеть от централизованных служб в плане функциональности. Централизованные службы могут препятствовать масштабируемости и надежности системы например, создавая узкое место или единую точку отказа
36. СУБД в архитектуре "клиент-сервер"
	1. Модель**Клиент–сервер** — это модель взаимодействия компьютеров в сети, при которой один узел (сервер) предоставляет ресурсы или услуги, а другие (клиенты) ими пользуются. В СУБД такая архитектура используется для **коллективного доступа к данным** и централизованного управления базами данных (например, MySQL). Сервером может быть как **компьютер**, так и **программное обеспечение** (ядро СУБД). Клиентами считаются устройства или программы, которые обращаются к серверу за услугами.
	2. Типы архитектуры «клиент–сервер»
		1. Одноуровневая
			1. Клиенты напрямую обращаются к серверу данных.
			2. Сервер только отвечает на запросы.
			3. Архитектура надёжная, но сложная в управлении.
			4. Требует синхронизации данных между рабочими станциями.
		2. Двухуровневая
			1. Есть сервер БД и прикладные программы.
			2. Возможны варианты:
			3. **Толстый клиент, тонкий сервер** — логика обработки у клиента.
			4. **Тонкий клиент, толстый сервер** — данные и логика на сервере.
			5. Плюсы: удобство, высокая производительность, масштабируемость.
			6. Минусы: снижение производительности при росте клиентов, риски безопасности, зависимость от одной СУБД.
		3. Трёхуровневая
			1. Клиент → сервер приложений → сервер БД.
			2. Клиент не обращается к БД напрямую.
			3. Плюсы: высокая безопасность, целостность данных, гибкость.
			4. Минус: усложнение архитектуры за счёт промежуточного ПО.
		4. Многоуровневая
			1. Несколько серверов приложений взаимодействуют между собой и со сторонними сервисами.
			2. Плюс: высокая гибкость и масштабируемость.
			3. Минус: сложность архитектуры и администрирования.
		5. Преимущества клиент–серверной архитектуры
			1. Централизованное хранение и управление данными.
			2. Высокий уровень безопасности.
			3. Хорошая масштабируемость.
			4. Повышенная производительность за счёт выделенного сервера.
		6. Недостатки
			1. Возможная перегрузка трафика при большом числе клиентов.
			2. Одна точка отказа при использовании одного сервера.
			3. Ограничение по числу подключений.
			4. Необходимость специального ПО и системного администрирования.
37. Серверы баз данных, принципы взаимодействия между клиентскими и серверными частями.
	1. **Сервер БД — это программно-аппаратный комплекс, обеспечивающий:**
		- хранение и управление данными (включая индексы, журналы транзакций)
		- обработки запросов (через ЯМД — язык манипулирования данными)
		- контроль целостности, безопасности и параллелизма (многопользовательский доступ);
		- журнализацию и восстановление после сбоев.
	2.  **Журнализация** – ключевой механизм, который обеспечивает надежность и целостность данных. Цель – гарантировать возможность восстановления данных в согласованное состояние после сбоев.
	3. **Принципы взаимодействия:**
		1. Клиент отправляет **запрос** (например, SQL-оператор) серверу по сети.
		2. Сервер:
			- проверяет синтаксис и права доступа (через ЯОД и системные каталоги);
			- формирует **план выполнения** (оптимизация запроса);
			- обращается к физическим структурам данных во внешней памяти (внутренняя модель);
			- выполняет операции (селекцию, соединение и т.п.), при необходимости используя буферизацию и кэширование;
			- возвращает **результат** клиенту (набор кортежей или статус операции).
	4. Клиент отображает данные или продолжает работу (в диалоговом или программном интерфейсе).
38. Проблема тиражирования данных
	1. **Тиражирование(репликация) данных** – в распределенных базах данных это технология распространений изменений, первоначально выполненных из одной копии блока данных, на другие копии. Различают:
		1. **синхронное тиражирование**, предусматривающее практически одновременное изменение данных во всех частях базы
		2. **асинхронное тиражирование**, предусматривающее изменение данных по очереди.
	2. Принципиальная характеристика тиражирования(репликации) данных(Data Replication – DR) заключается в отказе от физического распределения данных.
	3. Суть DR в том, что любая БД (как для СУБД, так и для работающих с ней пользователей) всегда является локальной. **Данные размещаются локально на том узле сети, где они обрабатываются+все транзакции в системе завершаются локально.**
	4. **DR** – набор технологий, позволяющий поддерживать несколько копий одних и  тех же данных  на разных узлах.
	5. **Репликация баз данных –** процесс копирования и синхронизации данных на нескольких серверах. Цель- обеспечение высокой доступности данных и повышение производительности системы. Репликация важна в системах, где нужна высокая доступность данных +минимизация времени простоя.(+предотвращает потерю данных+ позволяет распределять нагрузку между серверами).
	6. **Недостатки репликации:**
		1. cложность управления
		2. ресурсозатратность
		3. проблемы консистентности
	7. **Доп. инфа:**
		1. В рамках репликации существует ведущая копия(master), и несколько ведомых реплик(slave). Репликация не отменяет первичное копирование БД: для создания new реплики сначала необходимо сделать full копию данных с основного сервера, после запускается процесс репликации и изменения начинают синхронизироваться.
		2. Репликация нужна для :
			1. **отказоустойчивость** (один сервер вышел из строя – другие работют и обеспечивают непрерывный доступ к данным)
			2. **масштабирование** чтения
			3. **распределение нагрузки**
			4. **географическое распределение**
39. Хеширование (хеш-адресация)
	1. **Хеширование** – процесс, который преобразует любые данные в уникальную строку фиксированной длины.
	2. **Слово** **hash** – буквально “мешанина”/”путаница”. **Суть хеширования** - максимально запутать данные, чтобы из них нельзя было ничего восстановить.
	3. **Хеш** – строка фиксированной длины, которая создается из исходных данных с помощью хеш-функции. Берется текст, пропускается через хеш-функцию, и на выходе получается новая строка фиксированной длины, из которого не получится восстановить исходные данные+ она уникальна для каждого набора данных.
	4. Как работает хеш-функция:
		1. Сама по себе **хеш-функция – матем. часть  алгоритма хеширования. В ней юзается математика, основанная на операциях цикл.сдвига,побитовых преобразований, сможения по модулю+лог.операций И,ИЛИ,НЕ.** Операции комбинируются так, чтобы результат был максимально запутанным и необратимым+чуств. к любым изменениям вход. данных.
		2. Свойства сильной хеш-функции:
		3. **необратимость** (после превращения данных в хеш, их невозможно обратно вернуть)
		4. **чувствительность к изменениям** (лавинный эффект. Изменился хоть 1 символ исходника => изменился весь хеш)
		5. **фиксированная длина** (хеш всегда 1 размера вне зависимости от длины входных данных, если используется 1 и тот же алгоритм хеширования)
		6. **детерминированность** (1 и те же входные данные всегда дают одинаковый результат)
	5. Хеш-функции:
		1. **криптографические** (для защиты данных, используются в шифровании, цифровых подписях и там, где нужна высокая надежность)
		2. **некриптографические** (для оптимизации работы с данными, например для быстрого поиска или хранения инфы в хеш-таблицах)
		3. **Пример:** надо сохранить секретное сообщение, так, чтобы его нельзя было расшифровать. С помощью хеширования исходный текст превратится в длинную последовательность символов, которая полностью зависит от входных данных, но не раскрывает их.
	6. Популярные алгоритмы хеширования – SHA-1,SHA-256.( блоки от 160 до 512 бит).
40. Особенности интерфейса СУБД
	1. Интерфейс СУБД определяет способы взаимодействия пользователя (конечного или разработчика) с базой данных. Выделяются следующие ключевые особенности: 
	2. Два основных типа интерфейсов
	3. **Диалоговый интерфейс** - Предназначен для непосредственного взаимодействия пользователя с БД через графические или текстовые формы:
		1. формы ввода/редактирования данных,
		2. построители запросов (например, QBE в Access),
		3. визуальные отчёты и меню.
		4. Используется преимущественно конечными пользователями и администраторами.
		5. Пример: MS Access — формы, отчёты, конструкторы запросов.
	4. **Программный интерфейс** - Ориентирован на разработчиков и автоматизированные приложения:
		1. вызовы через API (например, ODBC/JDBC),
		2. встраиваемые SQL-запросы,
		3. программные модули (макросы, процедуры на VBA/PL/pgSQL и др.),
		4. языковые конструкции ЯМД (язык манипулирования данными).
		5. Позволяет реализовать интеграцию БД с внешними системами (САПР, АСУ и др.).
	5. **Языковые средства как часть интерфейса**
		1. **Язык описания данных (ЯОД)** — для определения структуры БД (таблиц, доменов, ограничений).
		2. **Язык манипулирования данными (ЯМД)** — для выполнения операций:
			1. SELECT, INSERT, UPDATE, DELETE (SQL),
			2. транзакции, управление доступом (GRANT/REVOKE).
			3. Языковые средства обеспечивают **независимость приложений от физического представления данных**.
	6. **Независимость от физической реализации**
		1. Одна из ключевых особенностей — **логическая независимость интерфейса от внутреннего устройства данных**.Пользователь работает с данными через внешнюю и концептуальную модели:
		2. внешняя модель отражает _вид данных для конкретного пользователя_,
		3. концептуальная — _общую логическую структуру всей БД_.
	7. **Внутренний уровень -** Изменения на физическом уровне (индексы, файлы, размещение на диске) не влияют на интерфейс и прикладные программы.
